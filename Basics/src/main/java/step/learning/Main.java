package step.learning;

import com.google.inject.Guice;
import com.google.inject.Injector;
import step.learning.services.ConfigModule;


public class Main {
    public static void main(String[] args) {
        // new App().run() ;
        // Контейнер - "модуль" внедрения зависимостей
        Injector injector = Guice.createInjector( new ConfigModule() ) ;
        // Resolve - решение зависимостей и создание объекта
        App app = injector.getInstance( App.class ) ;
        app.run() ;
    }

}
/*
    Практика
    При старте программа проводит "анализ" существующих классов на признак "запускаемости"
    Собирает эти классы в меню и предлагает выбор для запуска.
    Для запуска один из методов класса должен быть помечен как стартовый.
    Уточнения:
    - классы могут находиться в пакете "step.learning" и в его под-пакетах
    - уровень вложенности - один, под-под-пакеты уже не сканнируем
    - "запускаемость" класса обозначается аннотацией "DemoClass(priority)"
    - стартовый метод обозначается аннотацией "EntryPoint"
    - меню пользователя с бесконечным повтором и с пунктом "выход"

    Заметки по решению
    узнать имя пакета
     а) hardcode - взять из названия
     б) рефлексией
    имя пакета - имя каталога, но для работы с файлом нужно полное имя
     его поставляет ClassLoader, доступный через
     а) Thread.currentThread().getContextClassLoader()
     б) Main.class.getClassLoader()

 */
/*
    Установка Java
    1. IDE
     - Intellij Idea (Ultimate) под студентческой лицензией
     - NetBeans
     - Eclipse
    2. JDK - Java Development Kit - инструментарий разработчика (компилятор)
       JRE - Java Runtime Environment - "платформа" - среда запуска

    Java:
    Java ME (Micro Edition) - Java Card - для устройств с ограниченным фукнционалом
    Java SE (Standard Edition) - базовый "набор"
    Java EE (Enterprise Edition) - доп. инструменты (сервер, библиотеки и т.п.)

    Шаблоны проектов (системы сборки)
    Maven
    Ant
    Gradle
 */
/*
    Инверсия управления (иньекция зависимостей).
    Архитектурный паттерн, согласно которому классы вместо того чтобы
     самостоятельно создавать зависимые сущности, делегируют эту задачу
     специальному модулю - контейнеру зависимостей, который кроме задач
     внедрения может управлять "временем жизни" хранимых объектов.
    Без ИУ
     main() {
      new App().run();
     }
     class App {
      Dependency dep;          // зависимость - ссылка на сторонний объект
      ctor() { dep = new... }  // класс сам создает объект
      run() { ...dep... }
     }
    С ИУ
     class App {
       @Anno                 // Добавляется аннотация для обозначения зависимости
       Dependency dep;       // исчезает код создания объекта
       run() { ...dep... }
     }
     main() {
      containerDI = new( Config )       // конфигурация - настройка контейнера
      app = containerDI.Resolve( App )  // резолюция - создание объекта с зависимостями
      app.run();
     }

     Для реализации архитектуры ИУ обычно применяются готовые решения
     - Spring
     - Google Guice
     Для подключения пакетов нужно установить систему управления пакетами - Maven
     = Подключаем в проекте поддержку Maven :
        (Project explorer) - Basics -(ПКМ)- Add Framework Support - Maven
        меняется организация папок
        добавляется файл pom.xml
         в этом файле создаем секцию
          <dependencies>
          </dependencies>
        после запуска - появляется папка target, добавляем ее в .gitignore
     = На сайте-репозитории https://mvnrepository.com/repos/central
        ищем Guice, выбираем  com.google.inject » guice
        Копируем инструкцию, вставляем в pom.xml - <dependencies>
        <dependency>
            <groupId>com.google.inject</groupId>
            <artifactId>guice</artifactId>
            <version>5.1.0</version>
        </dependency>
        Нажимаем Reload (всплывающая кнопка или на панели Maven)

    Меняем архитектуру приложения
     Main-main() - только старт первого класса, всю активность переносим в
     новый класс App

    Как это работает?
     Контейнер DI содержит в себе набор типов, для которых нужны зависимости
     В простейшем представлении - это map<Class<?>, obj> - сопоставление
      типа и его объекта. В начале производится сканнирование зависимостей -
      поиск аннотаций @Inject, затем определяются классы, отвечающие за эти
      зависимости. Создаются объекты и заполняются поля в зависимом классе

    - возможна иньекция в private поля, это балансирует рекомендацию иньекции через конструктор
    - службы не требуют специальных аннотаций, иньектор их находит в данном пакете
    - Guice поддерживает два вида аннотаций (c одинаковой функциональностью):
       = javax.inject.*   -- рекомендуется для возможной совместимости при переносе проекта
       = com.google.inject.*
    - По умолчанию службы являются "Transient" - при новых обращениях создаются
        новые объекты. Альтернатива - @Singleton, при этом все запросы на иньекцию
        получат один и тот же объект
 */
/*
    Настройка IoC
    Под настройкой понимают связывание интерфейсов и их реализаций (классов),
    а также типов (классов) и их объектов.
    В Guice за настройку отвечает класс AbstractModule
    Объект, расширяющий этот класс, передается в Guice.createInjector
 */